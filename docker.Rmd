# Docker

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, warning = FALSE)
```

## Introduction to Docker

<a href="https://connpass-tokyo.s3.amazonaws.com/thumbs/80/52/80521f18aec0945dfedbb471dad6aa1a.png"><img src="https://connpass-tokyo.s3.amazonaws.com/thumbs/80/52/80521f18aec0945dfedbb471dad6aa1a.png" width="400/"></a>

### What is Docker?

* Platform for developing, shipping and running applications
* Infrastructure as application / code
* First version: 2013
* Company. Original dotCloud (2010), later named Docker
* Established [Open Container Initiative](https://www.opencontainers.org/)

As a software:

* [Docker Community Edition](https://www.docker.com/products/container-runtime)
* Docker Enterprise Edition


### Docker components

<a href="http://apachebooster.com/kb/wp-content/uploads/2017/09/docker-architecture.png"><img src="http://apachebooster.com/kb/wp-content/uploads/2017/09/docker-architecture.png" width="700/"></a>

* Read-only templates
* Containers are run from them
* Images are not run
* Images have several layers

<a href="https://i.stack.imgur.com/vGuay.png"><img src="https://i.stack.imgur.com/vGuay.png" width="700/"></a>


### Images versus containers

Image: set of layers. read-only templates. Inert.
An instance of an image is called a container.
When you start an image, you have a running container of this image. You can have many running containers of the same image.

The image is the recipe, the container is the cake.

https://stackoverflow.com/questions/23735149/what-is-the-difference-between-a-docker-image-and-a-container

### Docker vocabulary

```{bash}
docker
```

<img src="docs/images/docker_vocab.png" width="600/">

Get help:

```{bash}
docker run --help
```

<img src="docs/images/docker_run_help.png" width="750/">


<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

What are the following commands doing?

* `docker pull`
* `docker export`

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>



## Using existing images

### Getting started

Run the following in the terminal:

```{bash}
docker images
```

The `docker images` command lists the Docker images that you have on your computer.
<br>
Now run the following:

```{bash}
docker pull hello-world
```

Run `docker images` again: now you see the "hello-world" image listed!
<br>
`docker pull` imports an image from - by default - **Docker hub**.

<br>
We will see more in details the `docker images` and `docker run` commands, but let's first explore the **Docker images repositories**.


### Explore Docker hub

Images can be stored locally or shared in a registry.
<br>
[Docker hub](https://hub.docker.com/) is the main public registry for Docker images.
<br>

Let's search the keyword **ubuntu**:

<img src="docs/images/dockerhub_ubuntu.png" width="900/">


You can also search existing Docker images with the `docker search` command.
<br>
Example: let's look for images that have the keyword **blastp** in their name or description.

```{bash}
docker search blast
```

Too many results? You can apply some filters:

* Minimum number of **stars**: `docker search blast --filter stars=5`
* The image is an **official build**: `docker search blast --filter is-official=true`
* The image is an **automated build**: `docker search blast --filter is-automated=true`

```{bash}
# Apply one filter
docker search blast --filter stars=2

# Apply more than one filter
docker search blast --filter is-automated=true --filter stars=2
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

Use `docker search` to find a Docker image for the keyword `ubuntu`. Using the filters, answer the following questions:

* How many images are **official builds**?
* How many images have **3 or more stars**?
* How many images are **official builds** AND have **3 or more stars**?
* What is the NAME of the image with the highest number of stars?

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>

```{bash}
# Official builds
docker search ubuntu --filter is-official=true

# 3 or more stars
docker search ubuntu --filter stars=3

# Both filters
docker search ubuntu --filter is-official=true --filter stars=3
```

</details>


### docker pull: import an image

Say we are now interested in the `ubuntu` image from Docker hub. We can retrieve it with `docker pull`.

* By default, we get the latest image / latest release.

```{bash}
docker pull ubuntu
```

<img src="docs/images/docker_pull.png" width="650/">

* You can choose the version of Ubuntu you are fetching: check the different tags on the website (*latest* is also a tag):

<img src="docs/images/dockerhub_ubuntu_tags.png" width="850/">

Let's get the Ubuntu image with tag **18.04**:

<img src="docs/images/dockerhub_ubuntu_1804.png" width="850/">


```{bash}
docker pull ubuntu:18.04
```

**Where is the image now?**
<br>
As we have seen before, you can `docker images` in the terminal, to see a list of the most recently created images. `docker images` gives you information such as:

* Repository
* Tag
* Unique image ID
* Creation date
* Image size

<img src="docs/images/docker_images_list.png" width="650/">


<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

* Run `docker images`. How many images do you get?
* What is the size of the `ubuntu` image you just pulled?
* How many images do you get if you run `docker images --all`? What are those? Perhaps the [documentation](https://docs.docker.com/engine/reference/commandline/images/) can help.

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>

`docker images --all`: intermediate images.

</details>


### BioContainers

[BioContainers](https://biocontainers.pro/) is a community-driven project that provides the infrastructure and basic guidelines to create, manage and distribute bioinformatics packages and **containers**.
<br>
Images are normally created from [Bioconda](https://bioconda.github.io)
<br><br>
**How to search for images?**

* Ready-to use images on the [dedicated website](https://biocontainers.pro/registry)
* Entries are also stored in [Docker hub](https://hub.docker.com/u/biocontainers) and/or [Quay.io](https://quay.io) (RedHat registry)
* *Dockerfile recipes* (next topic!) on the [github page](https://github.com/BioContainers/containers).

**How to pull images from BioContainers?**
<br>
Example: [**FastQC** software](https://biocontainers.pro/#/tools/fastqc)

<img src="docs/images/biocontainers_fastqc.png" width="650/">

Load version / tag **v0.11.9_cv7** as:

    docker pull biocontainers/fastqc:v0.11.9_cv7


<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

* [Search](https://biocontainers.pro/registry) for the tool **blast**.
* Pull the Docker image with version **2.2.31** (check the instructions).

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>

    docker pull biocontainers/blast:2.2.31

</details>


### docker run: run image, i.e. start a container

Now we want to use what is **inside** the image.
<br>
`docker run` creates a fresh container (active instance of the image) from a **Docker (static) image**, and runs it.

<br>
The format is:<br>

docker run image:tag **command** (command being a command called *inside the image*)

<br>
We can start a container from the **ubuntu tag 18.04 image**, executing the command `ls` (stored in /bin).

```{bash}
docker run ubuntu:18.04 /bin/ls
```

<img src="docs/images/docker_run_ls.png" width="200/">

Now execute **ls** in your current working directory: is the result the same?

<br>

You can execute any program/command that is stored inside the image:

```{bash}
docker run ubuntu:18.04 /bin/whoami
docker run ubuntu:18.04 cat /etc/issue
```

You can either execute programs in the image from the command line (see above) or **execute a container interactively**, i.e. **"enter"** the container, with `docker run -it`.

```{bash}
docker run -it ubuntu:18.04 /bin/bash
```

If you want to leave and stop the container, type `exit`.
<br>

You can run the container as daemon (in background), instead of the default foreground running, with the `--detach` parameter:

```{bash}
docker run --detach ubuntu:18.04 tail -f /dev/null
```

Run container as daemon (in background) with a given name:

```{bash}
docker run --detach --name myubuntu ubuntu:18.04 tail -f /dev/null
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

Short hands on with docker run.

* Run the **hello-world** image:
  * What is happening?
* Now run the **blast** image from BioContainers we previously pulled (version 2.2.31):
  * Is something happening?
* Start a container **interactively** from the same image:
  * What is the default working directory? What is inside the directory?
  * Where is the `blastp` program located in the image?
  * Exit the container.

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>

```{bash}
# Run the hello-world image
docker run hello-world

# Run the blast image
docker run biocontainers/blast:2.2.31

# Start a container interactively from the blast image:
docker run -it biocontainers/blast:2.2.31

# Where is the blastp program located in the image?
which blastp
```

</details>


### docker ps: check containers status

List running containers:

```{bash}
docker ps
```

List all containers (whether they are running or not):

```{bash}
docker ps -a
```

Each container has a unique ID.

<br>
You can remove a container with `docker rm CONTAINER_ID`.

### docker exec: execute process in running container

Difference between `docker run` and `docker exec`: 

* `docker run` creates a temporary container, runs the command and stops the container.
* `docker exec` needs an already running container to query the command.

```{bash}
docker exec myubuntu uname -a
```

* Interactively

```{bash}
docker exec -it myubuntu /bin/bash
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

Exercise on playing with exec?

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>


### docker stop, start, restart: actions on container

Stop a running container with `docker stop`.

```{bash}
docker stop myubuntu

docker ps -a
```

Start a stopped container (does NOT create a new one):

```{bash}
docker start myubuntu

docker ps -a
```

Restart a running container: 

```{bash}
docker restart myubuntu

docker ps -a
```

Run with restart enabled (by default, Docker does not automatically restart the container when it exits):

```{bash}
docker run --restart=unless-stopped --detach --name myubuntu2 ubuntu:18.04 tail -f /dev/null
```

* [Restart policies](https://docs.docker.com/engine/reference/commandline/run/#restart-policies---restart): no (default), always, on-failure, unless-stopped

Update restart policy:

```{bash}
docker update --restart unless-stopped myubuntu
```


### docker rm, docker rmi: clean up!

`docker rm` is used to remove a **container** (set `-f` is the container is running, to force the removal):

```{bash}
docker rm myubuntu
docker rm -f myubuntu
```

`docker rmi` is used to remove an **image**:

```{bash}
docker rmi ubuntu:18.04
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>


#### Major clean

*docker system failing for me on a qlogin node: why? (I see from the documentation that it still exists) Version issue perhaps?*

Check used space
```{bash}
docker system df
```

Remove unused containers (and others) - **DO WITH CARE**
```{bash}
docker system prune
```

Remove ALL non-running containers, images, etc. - **DO WITH MUCH MORE CARE!!!**
```{bash}
docker system prune -a
```

* Reference: https://www.digitalocean.com/community/tutorials/how-to-remove-docker-images-containers-and-volumes


### Volumes

**I (Sarah) need to review the exercise!**

Let's try and run `blastp` in the **blast** image. <br>
We will run a simple blastp search following [this example](https://angus.readthedocs.io/en/2016/running-command-line-blast.html).

<br>
Let's get **fasta** files:

```{bash}
# We create first a directory where to store the files
mkdir fasta_files

# "cow" proteins from the NCBI/RefSeq database: let's get just a sample (one protein):
wget -O - ftp://ftp.ncbi.nih.gov/refseq/B_taurus/mRNA_Prot/cow.1.protein.faa.gz | gunzip | head -6 > fasta_files/cow.small.faa

# "human" proteins from the NCBI/RefSeq database:
wget -O - wget ftp://ftp.ncbi.nih.gov/refseq/H_sapiens/mRNA_Prot/human.1.protein.faa.gz | gunzip > fasta_files/human.1.protein.faa
```

Query the help of `blastp`:

```{bash}
docker run biocontainers/blast:2.2.31 blastp -h
```

Try to run `blastp`:

```{bash}
docker run biocontainers/blast:2.2.31 blastp -query fasta_files/cow.small.faa -db fasta_files/human.1.protein.faa
```

Error! 

<br>
Docker containers are **fully isolated**. It is necessary to mount volumes in order to handle input/output files.

Syntax: **--volume/-v** *path_in_host:path_in_container*


blastp -query cow.small.faa -db human.1.protein.faa

```{bash}
docker run --volume $(pwd)/fasta_files:/data/fasta biocontainers/blast:2.2.31 blastp -query /data/fasta/cow.small.faa -db /data/fasta/human.1.protein.faa
```

docker run --volume $(pwd)/fasta_files:/fasta biocontainers/blast:2.2.31 makeblastdb -in /fasta/human.1.protein.faa -dbtype prot


```{bash}
mkdir datatest
touch datatest/test
docker run --detach --volume $(pwd)/datatest:/scratch --name fastqc_container biocontainers/fastqc:v0.11.9_cv7 tail -f /dev/null
docker exec -ti fastqc_container /bin/bash
> ls -l /scratch
> exit
```

* Exercises:
1. Copy the 2 fastq files from available datasets in Github repository and place them in mounted directory
2. Run fastqc interactively (inside container): ```fastqc  /scratch/*.gz```
3. Run fastqc outside the container

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>




## Docker recipes

### Building recipes

All commands should be saved in a text file, named by default **Dockerfile**.

#### Basic instructions

Each row in the recipe corresponds to a **layer** of the final image.

**FROM**: parent image. Typically, an operating system. The **base layer**.

```docker
FROM ubuntu:18.04
```

**RUN**: the command to execute inside the image filesystem.
<br>
Think about it this way: every **RUN** line is essentially what you would run to install programs on a freshly installed Ubuntu OS.

```docker
RUN apt install wget
```

A basic recipe:

```docker
FROM ubuntu:18.04

RUN apt update && apt -y upgrade
RUN apt install -y wget
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

Explore this ... Dockerfile:

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>


#### More instructions

**MAINTAINER**

Who is maintaining the container?

```docker
MAINTAINER Toni Hermoso Pulido <toni.hermoso@crg.eu>
```

**WORKDIR**: all subsequent actions will be executed in that working directory

```docker
WORKDIR ~
```

**ADD, COPY**: add files to the image filesystem

Difference between ADD and COPY explained [here](https://stackoverflow.com/questions/24958140/what-is-the-difference-between-the-copy-and-add-commands-in-a-dockerfile) and [here](https://nickjanetakis.com/blog/docker-tip-2-the-difference-between-copy-and-add-in-a-dockerile)

**COPY**: lets you copy a local file or directory from your host (the machine from which you are building the image)

**ADD**: same, but ADD works also for URLs, and for .tar archives that will be automatically extracted upon being copied.


```docker
# COPY source destination
COPY ~/.bashrc .
```

**ENV, ARG**: run and build environment variables

Difference between ARG and ENV explained [here](https://vsupalov.com/docker-arg-vs-env/).


* **ARG** values: available only while the image is built.
* **ENV** values: available for the future running containers.


```{bash}
```

**CMD, ENTRYPOINT**: command to execute when generated container starts

The ENTRYPOINT specifies a command that will always be executed when the container starts. The CMD specifies arguments that will be fed to the ENTRYPOINT

<br>

In the example below, when the container is run without an argument, it will execute `echo "hello world"`.<br>
If it is run with the argument **nice** it will execute `echo "nice"`

```docker
FROM ubuntu:18.04
ENTRYPOINT ["/bin/echo"]
CMD ["hello world"]
```

A more complex recipe (save it in a text file named **Dockerfile**:

  ```docker
FROM ubuntu:18.04

MAINTAINER Toni Hermoso Pulido <toni.hermoso@crg.eu>

WORKDIR ~

RUN apt-get update && apt-get -y upgrade
RUN apt-get install -y wget

ENTRYPOINT ["/usr/bin/wget"]
CMD ["https://cdn.wp.nginx.com/wp-content/uploads/2016/07/docker-swarm-hero2.png"]
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>


### docker build

Implicitely looks for a **Dockerfile** file in the current directory:

```{bash}
docker build .
```

Same as:

```{bash}
docker build --file Dockerfile .
```

Syntax: **--file / -f**

**.** stands for the context (in this case, current directory) of the build process. This makes sense if copying files from filesystem, for instance. **IMPORTANT**: Avoid contexts (directories) overpopulated with files (even if not actually used in the recipe).

You can define a specific name for the image during the build process.

Syntax: **-t** *imagename:tag*. If not defined ```:tag``` default is latest.

```{bash}
docker build -t mytestimage .
```

The last line of installation should be **Successfully built ...**: then you are good to go.
<br>
Check with ``docker images`` that you see the newly built image in the list...


Then let's check the ID of the image and run it!

```{bash}
docker images

docker run f9f41698e2f8
docker run mytestimage
```

```{bash}
docker run f9f41698e2f8 https://cdn-images-1.medium.com/max/1600/1*_NQN6_YnxS29m8vFzWYlEg.png
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>


### docker tag

To tag a local image with ID "e23aaea5dff1" into the "ubuntu_wget" image name repository with version "1.0":

```{bash}
docker tag e23aaea5dff1 --tag ubuntu_wget:1.0
```

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>


### Build cache ###

Every line of a Dockerfile is actually an image/layer by itself.

Modify for instance the last bit of the previous image (let's change the image URL) and rebuild it (even with a different name/tag):

```docker
FROM ubuntu:18.04

MAINTAINER Toni Hermoso Pulido <toni.hermoso@crg.eu>

WORKDIR ~

RUN apt-get update && apt-get -y upgrade
RUN apt-get install -y wget

ENTRYPOINT ["/usr/bin/wget"]
CMD ["https://cdn-images-1.medium.com/max/1600/1*_NQN6_YnxS29m8vFzWYlEg.png"]
```

```{bash}
docker build -t mytestimage2 .
```

It will start from the last line.
This is OK most of the times and very convenient for testing and trying new steps, but it may lead to errors when versions are updated (either FROM image or included packages). For that it is benefitial to start from scratch with ```--no-cache``` tag.

```{bash}
docker build --no-cache -t mytestimage2 .
```

### More advanced image building

Different ways to build images.

Know your base system and their packages. Popular ones:
* [Debian](https://packages.debian.org)
* [CentOS](https://centos.pkgs.org/)
* [Alpine](https://pkgs.alpinelinux.org/packages)
* Conda. [Anaconda](https://anaconda.org/anaconda/repo), [Conda-forge](https://conda-forge.org/feedstocks/), [Bioconda](https://anaconda.org/bioconda/repo), etc.


### Additional commands

* **docker inspect**: Get details from containers (both running and stopped). Things such as IPs, volumes, etc.

* **docker logs**: Get *console* messages from running containers. Useful when using with web services.

* **docker commit**: Turn a container into an image. It make senses to use when modifying container interactively. However this is bad for reproducibility if no steps are saved.

Good for long-term reproducibility and for critical production environments:

* **docker save**: Save an image into a tar archive.

* **docker export**: Save a container into a tar archive.

* **docker import**: Import a tar archive into an image.

<center><h4 style="background-color: #e6fadc; display: inline-block;">**HANDS-ON**</h4></center>

<details>
<summary>
<h5 style="background-color: #e6fadc; display: inline-block;">*Answer*</h5>
</summary>
here
</details>



## Ports

The same as with volumes, but with ports, to access Internet services.

Syntax: **--publish/-p** *host:container*


```{bash}
docker run --detach --name webserver nginx
curl localhost:80
docker exec webserver curl localhost:80
docker rm -f webserver

```

```{bash}
docker run --detach --name webserver --publish 80:80 nginx
curl localhost:80
docker rm -f webserver
```

```{bash}
docker run --detach --name webserver -p 8080:80 nginx
curl localhost:80
curl localhost:8080
docker exec webserver curl localhost:80
docker exec webserver curl localhost:8080
docker rm -f webserver
```



